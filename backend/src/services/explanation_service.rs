use std::sync::Arc;
use chrono::{Duration, Utc};
use sqlx::PgPool;
use tracing::{info, warn};

use crate::db::recommendation_queries;
use crate::errors::{AppError, LlmError};
use crate::models::{
    ExplanationContext, NarrativeType, RecommendationExplanation,
    SignalGenerationParams,
};
use crate::services::llm_service::LlmService;
use crate::services::price_service;
use crate::services::signal_service::SignalService;

const EXPLANATION_TTL_HOURS: i64 = 1;

const DISCLAIMER: &str = "This analysis is generated by AI for educational purposes only. \
It does not constitute investment advice, a recommendation, or an offer to buy or sell any security. \
Past performance is not indicative of future results. Always conduct your own research and consider \
consulting a qualified financial advisor before making investment decisions.";

/// Generate (or retrieve cached) recommendation explanation for a stock symbol.
pub async fn get_or_generate_explanation(
    pool: &PgPool,
    llm_service: Arc<LlmService>,
    symbol: &str,
    narrative_type: NarrativeType,
    force_refresh: bool,
) -> Result<RecommendationExplanation, AppError> {
    let symbol = symbol.to_uppercase();
    info!("Generating explanation for {} (narrative: {}, refresh: {})", symbol, narrative_type, force_refresh);

    // 1. Check DB cache unless force refresh
    if !force_refresh {
        match recommendation_queries::get_cached_explanation(pool, &symbol).await {
            Ok(Some(cached)) => {
                info!("Found cached explanation for {}", symbol);
                // Parse cached JSON back into RecommendationExplanation
                if let Ok(explanation) = serde_json::from_str::<RecommendationExplanation>(&cached.explanation) {
                    return Ok(explanation);
                }
                warn!("Failed to parse cached explanation for {}, regenerating", symbol);
            }
            Ok(None) => {
                info!("No cached explanation for {}", symbol);
            }
            Err(e) => {
                warn!("Error checking explanation cache for {}: {}", symbol, e);
            }
        }
    }

    // 2. Build context from stock data and signals
    let context = build_explanation_context(pool, &symbol, narrative_type).await?;

    // 3. Generate explanation via LLM (or fallback)
    let explanation = if llm_service.is_enabled() {
        match generate_llm_explanation(&llm_service, &context).await {
            Ok(expl) => expl,
            Err(e) => {
                warn!("LLM explanation generation failed for {}: {}. Using fallback.", symbol, e);
                generate_fallback_explanation(&context)
            }
        }
    } else {
        info!("LLM disabled, using fallback explanation for {}", symbol);
        generate_fallback_explanation(&context)
    };

    // 4. Cache in database
    let now = Utc::now();
    let expires = now + Duration::hours(EXPLANATION_TTL_HOURS);
    if let Ok(json_str) = serde_json::to_string(&explanation) {
        let factors_snapshot = serde_json::to_value(&context).unwrap_or(serde_json::Value::Null);
        if let Err(e) = recommendation_queries::cache_explanation(
            pool, &symbol, &json_str, &factors_snapshot, now, expires,
        ).await {
            warn!("Failed to cache explanation for {}: {}", symbol, e);
        }
    }

    Ok(explanation)
}

/// Build context by fetching price data and generating signals.
async fn build_explanation_context(
    pool: &PgPool,
    symbol: &str,
    narrative_type: NarrativeType,
) -> Result<ExplanationContext, AppError> {
    // Fetch price history
    let price_data = price_service::get_history(pool, symbol).await?;

    if price_data.is_empty() {
        return Err(AppError::NotFound(format!("No price data found for symbol: {}", symbol)));
    }

    // Extract prices (oldest first for indicators)
    let mut prices: Vec<f64> = price_data
        .iter()
        .filter_map(|p| p.close_price.to_string().parse::<f64>().ok())
        .collect();
    prices.reverse();

    let current_price = *prices.last().unwrap_or(&0.0);

    // Calculate basic metrics
    let price_change_pct = if prices.len() >= 21 {
        let past = prices[prices.len().saturating_sub(21)];
        if past > 0.0 {
            Some(((current_price - past) / past) * 100.0)
        } else {
            None
        }
    } else {
        None
    };

    let high_52w = if prices.len() >= 252 {
        prices.iter().rev().take(252).cloned().reduce(f64::max)
    } else {
        prices.iter().cloned().reduce(f64::max)
    };

    let low_52w = if prices.len() >= 252 {
        prices.iter().rev().take(252).cloned().reduce(f64::min)
    } else {
        prices.iter().cloned().reduce(f64::min)
    };

    // Calculate annualized volatility from daily returns
    let volatility = if prices.len() >= 30 {
        let returns: Vec<f64> = prices.windows(2)
            .map(|w| (w[1] / w[0]).ln())
            .collect();
        let mean = returns.iter().sum::<f64>() / returns.len() as f64;
        let variance = returns.iter()
            .map(|r| (r - mean).powi(2))
            .sum::<f64>() / (returns.len() - 1) as f64;
        Some(variance.sqrt() * (252.0_f64).sqrt() * 100.0) // annualized %
    } else {
        None
    };

    // Calculate max drawdown
    let max_drawdown = if prices.len() >= 10 {
        let mut peak = prices[0];
        let mut max_dd = 0.0_f64;
        for &p in &prices {
            if p > peak { peak = p; }
            let dd = (p - peak) / peak;
            if dd < max_dd { max_dd = dd; }
        }
        Some(max_dd * 100.0)
    } else {
        None
    };

    // Try to generate signals for context
    let (signal_direction, signal_probability, signal_confidence, signal_factors) =
        if prices.len() >= 60 {
            let signal_service = SignalService::new(pool.clone());
            let volumes: Vec<f64> = vec![1_000_000.0; prices.len()];
            let params = SignalGenerationParams {
                ticker: symbol.to_string(),
                prices: prices.clone(),
                volumes,
                horizons: vec![3],
                current_price,
            };

            match signal_service.generate_signals(params).await {
                Ok(response) => {
                    // Find combined signal
                    let combined = response.signals.iter()
                        .find(|s| s.signal_type == crate::models::SignalType::Combined);

                    if let Some(sig) = combined {
                        let factors: Vec<String> = sig.contributing_factors.0.factors.iter()
                            .map(|f| f.interpretation.clone())
                            .collect();

                        (
                            Some(sig.direction.to_string()),
                            Some(sig.probability),
                            Some(sig.confidence_level.to_string()),
                            factors,
                        )
                    } else if let Some(sig) = response.signals.first() {
                        let factors: Vec<String> = sig.contributing_factors.0.factors.iter()
                            .map(|f| f.interpretation.clone())
                            .collect();

                        (
                            Some(sig.direction.to_string()),
                            Some(sig.probability),
                            Some(sig.confidence_level.to_string()),
                            factors,
                        )
                    } else {
                        (None, None, None, vec![])
                    }
                }
                Err(e) => {
                    warn!("Failed to generate signals for context: {}", e);
                    (None, None, None, vec![])
                }
            }
        } else {
            (None, None, None, vec![])
        };

    // Calculate RSI
    let rsi_14 = if prices.len() >= 15 {
        let rsi_vals = crate::services::indicators::rsi(&prices, 14);
        rsi_vals.last().and_then(|&v| v)
    } else {
        None
    };

    Ok(ExplanationContext {
        symbol: symbol.to_string(),
        current_price,
        price_change_pct,
        high_52w,
        low_52w,
        volatility,
        beta: None, // requires market data comparison
        rsi_14,
        signal_direction,
        signal_probability,
        signal_confidence,
        signal_factors,
        max_drawdown,
        sharpe_ratio: None, // would require risk-free rate
        narrative_type,
    })
}

/// Generate explanation using the LLM service.
async fn generate_llm_explanation(
    llm_service: &LlmService,
    context: &ExplanationContext,
) -> Result<RecommendationExplanation, LlmError> {
    let prompt = build_prompt(context);

    info!("Sending explanation prompt for {} ({} chars)", context.symbol, prompt.len());

    let response = llm_service.generate_completion(prompt).await?;

    parse_llm_response(&response, context)
}

/// Build the prompt for the LLM based on context and narrative type.
fn build_prompt(ctx: &ExplanationContext) -> String {
    let narrative_instruction = match ctx.narrative_type {
        NarrativeType::Valuation => {
            "Focus on VALUATION analysis. Discuss whether the stock appears fairly valued, \
             overvalued, or undervalued based on price metrics, historical price range, and \
             how the current price compares to its 52-week range. Consider price momentum \
             and mean-reversion potential."
        }
        NarrativeType::Growth => {
            "Focus on GROWTH analysis. Discuss the stock's price momentum, trend strength, \
             and whether technical indicators suggest continued upward trajectory or \
             deceleration. Consider moving average alignment and momentum indicators."
        }
        NarrativeType::Risk => {
            "Focus on RISK analysis. Discuss the stock's volatility, maximum drawdown, \
             beta exposure, and overall risk profile. Highlight what the risk metrics \
             suggest about downside protection and portfolio impact."
        }
        NarrativeType::Contrarian => {
            "Focus on CONTRARIAN analysis. Look at signals that go against the current \
             consensus. If the stock is trending down, discuss potential mean-reversion. \
             If trending up, discuss overextension risks. Consider RSI extremes and \
             deviation from moving averages."
        }
        NarrativeType::Dividend => {
            "Focus on INCOME/DIVIDEND analysis perspective. Discuss the stock's suitability \
             for income-seeking investors based on stability, low volatility, and defensive \
             characteristics. Note that specific dividend data may not be available, so \
             focus on price stability and risk metrics."
        }
        NarrativeType::Balanced => {
            "Provide a BALANCED analysis covering valuation, momentum, risk, and outlook. \
             Weigh technical signals, volatility metrics, and price trends equally to \
             give a well-rounded perspective."
        }
    };

    let mut data_section = format!(
        "STOCK: {symbol}\nCURRENT PRICE: ${price:.2}",
        symbol = ctx.symbol,
        price = ctx.current_price,
    );

    if let Some(change) = ctx.price_change_pct {
        data_section.push_str(&format!("\n20-DAY PRICE CHANGE: {:.2}%", change));
    }

    if let (Some(high), Some(low)) = (ctx.high_52w, ctx.low_52w) {
        data_section.push_str(&format!("\n52-WEEK RANGE: ${:.2} - ${:.2}", low, high));
        if high > low {
            let position = ((ctx.current_price - low) / (high - low)) * 100.0;
            data_section.push_str(&format!(" (currently at {:.0}% of range)", position));
        }
    }

    if let Some(vol) = ctx.volatility {
        data_section.push_str(&format!("\nANNUALIZED VOLATILITY: {:.2}%", vol));
    }

    if let Some(dd) = ctx.max_drawdown {
        data_section.push_str(&format!("\nMAX DRAWDOWN: {:.2}%", dd));
    }

    if let Some(rsi) = ctx.rsi_14 {
        data_section.push_str(&format!("\nRSI (14): {:.1}", rsi));
    }

    if let Some(ref direction) = ctx.signal_direction {
        data_section.push_str(&format!("\nSIGNAL DIRECTION: {}", direction));
    }

    if let Some(prob) = ctx.signal_probability {
        data_section.push_str(&format!("\nSIGNAL PROBABILITY: {:.0}%", prob * 100.0));
    }

    if let Some(ref conf) = ctx.signal_confidence {
        data_section.push_str(&format!("\nSIGNAL CONFIDENCE: {}", conf));
    }

    if !ctx.signal_factors.is_empty() {
        data_section.push_str("\n\nCONTRIBUTING FACTORS:");
        for factor in &ctx.signal_factors {
            data_section.push_str(&format!("\n  - {}", factor));
        }
    }

    format!(
        r#"Analyze the following stock and generate an educational investment analysis.

{narrative_instruction}

{data_section}

INSTRUCTIONS:
Generate a structured analysis in valid JSON format with these exact fields:

1. "headline": A concise 1-sentence summary of the analysis thesis (max 120 chars)
2. "narrative": A 2-4 paragraph educational analysis. Use clear language suitable for retail investors. Reference specific data points from above. Be factual and objective.
3. "key_factors": An array of 3-5 key factors (each a string, 1-2 sentences). These should be the most important observations supporting the analysis.
4. "risk_considerations": An array of 2-3 risk factors (each a string, 1-2 sentences). These should highlight potential downsides and uncertainties.

CRITICAL REQUIREMENTS:
- Do NOT provide specific buy/sell recommendations
- Frame analysis probabilistically ("may", "suggests", "historically tends to")
- Reference specific numbers from the provided data
- Be balanced - mention both positive and negative aspects
- Use educational, not advisory, language
- Keep total response under 800 words

Respond ONLY with valid JSON, no markdown code fences, no extra text:
{{"headline": "...", "narrative": "...", "key_factors": ["...", "..."], "risk_considerations": ["...", "..."]}}"#,
        narrative_instruction = narrative_instruction,
        data_section = data_section,
    )
}

/// Parse the LLM response JSON into a RecommendationExplanation.
fn parse_llm_response(
    response: &str,
    ctx: &ExplanationContext,
) -> Result<RecommendationExplanation, LlmError> {
    // Try to extract JSON from the response (handle markdown fences)
    let json_str = extract_json(response);

    let parsed: serde_json::Value = serde_json::from_str(&json_str)
        .map_err(|e| LlmError::InvalidResponse(format!("Failed to parse LLM JSON: {}", e)))?;

    let headline = parsed["headline"]
        .as_str()
        .unwrap_or("Analysis generated")
        .to_string();

    let narrative = parsed["narrative"]
        .as_str()
        .unwrap_or("Analysis temporarily unavailable.")
        .to_string();

    let key_factors = parsed["key_factors"]
        .as_array()
        .map(|arr| {
            arr.iter()
                .filter_map(|v| v.as_str())
                .map(String::from)
                .collect()
        })
        .unwrap_or_else(|| vec!["Factor analysis unavailable".to_string()]);

    let risk_considerations = parsed["risk_considerations"]
        .as_array()
        .map(|arr| {
            arr.iter()
                .filter_map(|v| v.as_str())
                .map(String::from)
                .collect()
        })
        .unwrap_or_else(|| vec!["Risk analysis unavailable".to_string()]);

    let now = Utc::now();

    Ok(RecommendationExplanation {
        symbol: ctx.symbol.clone(),
        headline,
        narrative,
        key_factors,
        risk_considerations,
        narrative_type: ctx.narrative_type,
        signal_direction: ctx.signal_direction.clone(),
        confidence: ctx.signal_confidence.clone(),
        generated_at: now,
        expires_at: now + Duration::hours(EXPLANATION_TTL_HOURS),
        disclaimer: DISCLAIMER.to_string(),
    })
}

/// Extract JSON from a response that might contain markdown fences.
fn extract_json(response: &str) -> String {
    let trimmed = response.trim();

    // Try to strip markdown code fences
    if trimmed.starts_with("```") {
        let without_opening = if let Some(idx) = trimmed.find('\n') {
            &trimmed[idx + 1..]
        } else {
            trimmed.trim_start_matches("```json").trim_start_matches("```")
        };
        let without_closing = without_opening.trim_end_matches("```").trim();
        return without_closing.to_string();
    }

    // Try to find JSON object boundaries
    if let (Some(start), Some(end)) = (trimmed.find('{'), trimmed.rfind('}')) {
        if start < end {
            return trimmed[start..=end].to_string();
        }
    }

    trimmed.to_string()
}

/// Generate a fallback explanation when LLM is unavailable.
fn generate_fallback_explanation(ctx: &ExplanationContext) -> RecommendationExplanation {
    let direction_text = ctx.signal_direction.as_deref().unwrap_or("neutral");
    let confidence_text = ctx.signal_confidence.as_deref().unwrap_or("low");

    let headline = format!(
        "{} shows {} technical signals with {} confidence",
        ctx.symbol, direction_text, confidence_text
    );

    let mut narrative = format!(
        "{symbol} is currently trading at ${price:.2}.",
        symbol = ctx.symbol,
        price = ctx.current_price,
    );

    if let Some(change) = ctx.price_change_pct {
        narrative.push_str(&format!(
            " Over the past 20 trading days, the stock has moved {:.2}%.",
            change
        ));
    }

    if let (Some(high), Some(low)) = (ctx.high_52w, ctx.low_52w) {
        let position = if high > low {
            ((ctx.current_price - low) / (high - low)) * 100.0
        } else {
            50.0
        };
        narrative.push_str(&format!(
            " The 52-week range is ${:.2} to ${:.2}, with the current price at approximately {:.0}% of that range.",
            low, high, position
        ));
    }

    if let Some(vol) = ctx.volatility {
        narrative.push_str(&format!(
            "\n\nThe annualized volatility stands at {:.2}%, which {}.",
            vol,
            if vol > 40.0 { "indicates high price variability" }
            else if vol > 25.0 { "suggests moderate price fluctuation" }
            else { "points to relatively stable price behavior" }
        ));
    }

    if let Some(rsi) = ctx.rsi_14 {
        narrative.push_str(&format!(
            " The 14-day RSI is at {:.1}, which {}.",
            rsi,
            if rsi > 70.0 { "may indicate overbought conditions" }
            else if rsi < 30.0 { "may indicate oversold conditions" }
            else { "falls within the neutral zone" }
        ));
    }

    narrative.push_str("\n\nNote: This is a template-based analysis generated without AI assistance. For more detailed insights, enable the LLM service.");

    let mut key_factors = Vec::new();

    if let Some(change) = ctx.price_change_pct {
        key_factors.push(format!("20-day price change: {:.2}%", change));
    }
    if let Some(vol) = ctx.volatility {
        key_factors.push(format!("Annualized volatility: {:.2}%", vol));
    }
    if let Some(rsi) = ctx.rsi_14 {
        key_factors.push(format!("RSI (14): {:.1}", rsi));
    }
    if let Some(ref dir) = ctx.signal_direction {
        key_factors.push(format!("Technical signal direction: {}", dir));
    }
    if key_factors.is_empty() {
        key_factors.push("Limited data available for analysis".to_string());
    }

    let mut risk_considerations = vec![
        "Past price performance does not guarantee future results.".to_string(),
    ];
    if let Some(dd) = ctx.max_drawdown {
        risk_considerations.push(format!(
            "Historical maximum drawdown of {:.2}% suggests significant downside risk.",
            dd
        ));
    }
    risk_considerations.push(
        "This analysis is based solely on technical price data and does not include fundamental metrics.".to_string(),
    );

    let now = Utc::now();

    RecommendationExplanation {
        symbol: ctx.symbol.clone(),
        headline,
        narrative,
        key_factors,
        risk_considerations,
        narrative_type: ctx.narrative_type,
        signal_direction: ctx.signal_direction.clone(),
        confidence: ctx.signal_confidence.clone(),
        generated_at: now,
        expires_at: now + Duration::hours(EXPLANATION_TTL_HOURS),
        disclaimer: DISCLAIMER.to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_json_plain() {
        let input = r#"{"headline": "Test", "narrative": "Test narrative"}"#;
        let result = extract_json(input);
        assert!(result.contains("headline"));
    }

    #[test]
    fn test_extract_json_with_markdown_fences() {
        let input = "```json\n{\"headline\": \"Test\"}\n```";
        let result = extract_json(input);
        assert_eq!(result, "{\"headline\": \"Test\"}");
    }

    #[test]
    fn test_extract_json_with_surrounding_text() {
        let input = "Here is the analysis:\n{\"headline\": \"Test\"}\nEnd of response.";
        let result = extract_json(input);
        assert_eq!(result, "{\"headline\": \"Test\"}");
    }

    #[test]
    fn test_build_prompt_contains_symbol() {
        let ctx = ExplanationContext {
            symbol: "AAPL".to_string(),
            current_price: 175.50,
            price_change_pct: Some(3.2),
            high_52w: Some(199.62),
            low_52w: Some(130.00),
            volatility: Some(25.5),
            beta: None,
            rsi_14: Some(55.0),
            signal_direction: Some("bullish".to_string()),
            signal_probability: Some(0.65),
            signal_confidence: Some("medium".to_string()),
            signal_factors: vec!["RSI: 55.0 - Neutral".to_string()],
            max_drawdown: Some(-12.5),
            sharpe_ratio: None,
            narrative_type: NarrativeType::Balanced,
        };

        let prompt = build_prompt(&ctx);
        assert!(prompt.contains("AAPL"));
        assert!(prompt.contains("175.50"));
        assert!(prompt.contains("25.50%")); // volatility
        assert!(prompt.contains("bullish"));
        assert!(prompt.contains("BALANCED"));
    }

    #[test]
    fn test_build_prompt_valuation_narrative() {
        let ctx = ExplanationContext {
            symbol: "MSFT".to_string(),
            current_price: 380.00,
            price_change_pct: None,
            high_52w: None,
            low_52w: None,
            volatility: None,
            beta: None,
            rsi_14: None,
            signal_direction: None,
            signal_probability: None,
            signal_confidence: None,
            signal_factors: vec![],
            max_drawdown: None,
            sharpe_ratio: None,
            narrative_type: NarrativeType::Valuation,
        };

        let prompt = build_prompt(&ctx);
        assert!(prompt.contains("VALUATION"));
        assert!(prompt.contains("MSFT"));
    }

    #[test]
    fn test_parse_llm_response_valid_json() {
        let response = r#"{"headline": "AAPL shows strong momentum", "narrative": "Apple is trending upward.", "key_factors": ["Strong RSI", "Bullish MACD"], "risk_considerations": ["High volatility"]}"#;
        let ctx = ExplanationContext {
            symbol: "AAPL".to_string(),
            current_price: 175.0,
            price_change_pct: None,
            high_52w: None,
            low_52w: None,
            volatility: None,
            beta: None,
            rsi_14: None,
            signal_direction: Some("bullish".to_string()),
            signal_probability: Some(0.7),
            signal_confidence: Some("high".to_string()),
            signal_factors: vec![],
            max_drawdown: None,
            sharpe_ratio: None,
            narrative_type: NarrativeType::Balanced,
        };

        let result = parse_llm_response(response, &ctx).unwrap();
        assert_eq!(result.symbol, "AAPL");
        assert_eq!(result.headline, "AAPL shows strong momentum");
        assert_eq!(result.key_factors.len(), 2);
        assert_eq!(result.risk_considerations.len(), 1);
        assert!(result.disclaimer.contains("educational purposes"));
    }

    #[test]
    fn test_fallback_explanation() {
        let ctx = ExplanationContext {
            symbol: "TSLA".to_string(),
            current_price: 250.0,
            price_change_pct: Some(-5.0),
            high_52w: Some(300.0),
            low_52w: Some(150.0),
            volatility: Some(45.0),
            beta: None,
            rsi_14: Some(28.0),
            signal_direction: Some("bearish".to_string()),
            signal_probability: Some(0.6),
            signal_confidence: Some("medium".to_string()),
            signal_factors: vec![],
            max_drawdown: Some(-25.0),
            sharpe_ratio: None,
            narrative_type: NarrativeType::Risk,
        };

        let result = generate_fallback_explanation(&ctx);
        assert_eq!(result.symbol, "TSLA");
        assert!(result.narrative.contains("250.00"));
        assert!(result.narrative.contains("45.00%"));
        assert!(result.narrative.contains("oversold"));
        assert!(!result.key_factors.is_empty());
        assert!(result.disclaimer.contains("educational"));
    }
}
